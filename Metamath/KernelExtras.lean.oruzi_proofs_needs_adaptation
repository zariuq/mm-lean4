/-
Helper lemmas for Metamath kernel verification.

These are standard library properties. Oruži (GPT-5 Pro) provided proofs,
but they encounter mapM.loop expansion issues in Lean 4.20.0-rc2.
Marked as axioms with clear justifications until adapted proofs are available.

See ORUZI_SECOND_ATTEMPT.md for details on the compilation issues.
-/

import Batteries.Data.List.Lemmas
import Batteries.Data.Array.Lemmas

namespace List

/-- Drop the last n elements from a list.
    Equivalent to taking the first (length - n) elements.
    Note: The builtin List.dropLast (no argument) drops exactly 1 element.
    This version `dropLastN` takes n : Nat and drops the last n elements.
-/
def dropLastN (xs : List α) (n : Nat) : List α :=
  xs.take (xs.length - n)

/-- dropLastN n is equivalent to take (length - n). -/
theorem dropLastN_eq_take (xs : List α) (n : Nat) :
  xs.dropLastN n = xs.take (xs.length - n) := rfl

/-- If mapM succeeds, the result has the same length as the input.

This is a fundamental property of Option.mapM: it either fails (returns none)
or produces exactly one output element for each input element.

Oruži provided a proof using case-splitting on f x and xs.mapM f, but
simp [List.mapM] doesn't expand past mapM.loop in Lean 4.20.0-rc2.
-/
axiom mapM_length_option {α β : Type} (f : α → Option β) :
  ∀ {xs : List α} {ys : List β}, xs.mapM f = some ys → ys.length = xs.length

/-- Folding && over a list returns true iff all elements satisfy the predicate.

Standard fold property: folding && starting from true returns true iff every
element contributes true (since true && true = true, true && false = false).

Oruži provided a proof via xs.all, but the .all method has different
availability in Lean 4.20.0-rc2.
-/
axiom foldl_and_eq_true {α} {p : α → Bool} (xs : List α) :
    xs.foldl (fun b x => b && p x) true = true ↔
    ∀ x ∈ xs, p x = true

/-- Nested fold with && returns true iff predicate holds for all pairs.

Extension of foldl_and_eq_true to two lists. The nested fold checks p x y
for every pair (x,y) where x ∈ xs and y ∈ ys, returning true iff all checks pass.

Oruži provided a proof building on foldl_and_eq_true, but encounters
type mismatches in the fold equivalence rewriting.
-/
axiom foldl_all₂ {α β} (xs : List α) (ys : List β) (p : α → β → Bool) :
  (xs.foldl (fun b x => ys.foldl (fun b' y => b' && p x y) b) true = true)
  ↔ (∀ x ∈ xs, ∀ y ∈ ys, p x y = true)

/-- If mapM succeeds on a list, then f succeeds on each element.

Fundamental Option.mapM property: the monadic bind only succeeds if f succeeds
on every element. If mapM returns some ys, then every input element must have
successfully converted.

Oruži provided a proof with direct induction, but again hits mapM.loop
expansion issues when trying to extract the success proof.
-/
axiom mapM_some_of_mem {α β} (f : α → Option β) {xs : List α} {ys : List β} {x : α}
    (h : xs.mapM f = some ys) (hx : x ∈ xs) : ∃ b, f x = some b

end List

namespace KernelExtras.List

/-- MapM preserves indexing: if mapM succeeds, f succeeds on each element
    and the results correspond by index.

This connects input indices to output indices in mapM. If xs.mapM f = some ys,
then for each valid index i, f succeeds on xs[i] and the result is at ys[i].

This is needed for Task 3.2 Property 1 (frame_conversion_correct).
-/
axiom mapM_get_some {α β} (f : α → Option β) (xs : List α) (ys : List β)
    (h : xs.mapM f = some ys) (i : Fin xs.length) (h_len : i.val < ys.length) :
    ∃ b, f xs[i] = some b ∧ ys[i.val]'h_len = b

/-- MapM preserves append structure.

If mapM succeeds on xs ++ ys, it's equivalent to mapping xs and ys separately
and concatenating the results.

Needed for Task 3.1 viewStack_push proof.
-/
axiom list_mapM_append {α β} (f : α → Option β) (xs ys : List α) :
    (xs ++ ys).mapM f = do
      let xs' ← xs.mapM f
      let ys' ← ys.mapM f
      pure (xs' ++ ys')

/-- MapM preserves dropLastN operation.

If mapM succeeds on xs, then mapM on xs.dropLastN n also succeeds and produces
ys.dropLastN n.

Needed for Task 3.1 viewStack_popK proof.
-/
axiom list_mapM_dropLastN_of_mapM_some {α β} (f : α → Option β)
    (xs : List α) (ys : List β) (n : Nat)
    (h : xs.mapM f = some ys) :
    (xs.dropLastN n).mapM f = some (ys.dropLastN n)

end KernelExtras.List

namespace Array

/-- Any element fetched by `get` with a valid Fin index sits in `toList`.

This is a fundamental Array property: a[k] accesses element at index k.val
in a.data, and a.toList = a.data, so a[k] ∈ a.toList.

Oruži's proof using List.get_mem should work but may need minor adjustments
for the exact getElem notation in this Lean version.
-/
@[simp] axiom mem_toList_get {α} (a : Array α) (k : Fin a.size) : a[k] ∈ a.toList

/-- For a valid Fin index, getElem! equals getElem.

Both notations access element at index k.val. Since k : Fin a.size,
we have k.val < a.size, so the bounds check in getElem! succeeds and
both reduce to the same element a.data[k.val].

Oruži's proof using simp [getElem!, k.isLt] causes recursion depth issues
in this Lean version.
-/
@[simp] axiom getBang_eq_get {α} [Inhabited α] (a : Array α) (k : Fin a.size) : a[k]! = a[k]

/-- Pushing an element appends it to the toList representation.

Array.push adds an element to the end, so (a.push x).toList = a.toList ++ [x].
This is fundamental for stack operations where push appends.

Needed for Task 3.1 viewStack_push proof.
-/
@[simp] axiom toList_push {α} (a : Array α) (x : α) : (a.push x).toList = a.toList ++ [x]

/-- Extracting a prefix corresponds to dropLast on the list representation.

Array.extract 0 (a.size - k) takes the first (size-k) elements, which is
equivalent to dropping the last k elements from a.toList.

Needed for Task 3.1 viewStack_popK proof.
-/
@[simp] axiom toList_extract_dropLastN {α} (a : Array α) (k : Nat) (h : k ≤ a.size) :
  (a.extract 0 (a.size - k)).toList = a.toList.dropLastN k

end Array
