theorem assert_step_ok
  (db : Verify.DB) (pr pr' : Verify.ProofState) (label : String)
  (Γ : Spec.Database) (fr_spec : Spec.Frame) (stack_spec : List Spec.Expr)
  (fr_assert : Spec.Frame) (e_assert : Spec.Expr)
  (f_impl : Verify.Formula) (fr_impl : Verify.Frame) :
  ProofStateInv db pr Γ fr_spec stack_spec →
  db.find? label = some (Verify.Object.assert f_impl fr_impl label) →
  toFrame db fr_impl = some fr_assert →
  toExprOpt f_impl = some e_assert →
  Γ label = some (fr_assert, e_assert) →
  Verify.DB.stepNormal db pr label = Except.ok pr' →
  ∃ (stack_new : List Spec.Expr) (e_conclusion : Spec.Expr),
    ProofStateInv db pr' Γ fr_spec stack_new ∧
    -- Stack transformation: pop "needed" hypotheses, push conclusion
    (∃ needed : List Spec.Expr,
      stack_new = (stack_spec.dropLastN fr_impl.hyps.size) ++ [e_conclusion]) := by
  intro inv h_find h_fr_assert h_expr h_db_lookup h_step

  -- Unfold stepNormal to expose stepAssert
  unfold Verify.DB.stepNormal at h_step
  simp [h_find] at h_step
  -- h_step : db.stepAssert pr f_impl fr_impl = Except.ok pr'

  -- Get checkHyp success from stepAssert
  unfold Verify.DB.stepAssert at h_step
  cases h_hyp_size : (fr_impl.hyps.size ≤ pr.stack.size) with
  | false =>
    simp [h_hyp_size] at h_step
  | true =>
    simp [h_hyp_size] at h_step

    -- Calculate offset
    let off := pr.stack.size - fr_impl.hyps.size
    have h_off : off + fr_impl.hyps.size = pr.stack.size := Nat.sub_add_cancel h_hyp_size

    -- Extract checkHyp result from the do-block
    cases h_chk : Verify.DB.checkHyp db fr_impl.hyps pr.stack ⟨off, h_off⟩ 0 ∅ with
    | error e => simp [h_chk] at h_step
    | ok σ_impl =>
      simp [h_chk] at h_step

      -- Get well-formedness conditions from checkHyp success
      have assert_hyps_wf : HypsWellFormed db fr_impl.hyps :=
        checkHyp_success_implies_HypsWellFormed db fr_impl.hyps pr.stack ⟨off, h_off⟩ σ_impl h_chk

      have assert_floats_wf : FloatsWellStructured db fr_impl.hyps pr.stack ⟨off, h_off⟩ :=
        checkHyp_success_implies_FloatsWellStructured db fr_impl.hyps pr.stack ⟨off, h_off⟩ σ_impl h_chk

      -- Extract TypedSubst witness using Phase 5 infrastructure
      have ⟨σ_typed, h_typed⟩ : ∃ (σ_typed : Bridge.TypedSubst fr_assert),
        toSubstTyped fr_assert σ_impl = some σ_typed := by
        -- Get allM success from checkHyp success
        have h_allM : (Bridge.floats fr_assert).allM (fun (c, v) => checkFloat σ_impl c v) = some true := by
          -- Frame with empty DVs for checkHyp_validates_floats
          have h_fr_hypsOnly : toFrame db { dj := #[], hyps := fr_impl.hyps } = some ⟨fr_assert.mand, []⟩ := by
            unfold toFrame at h_fr_assert ⊢
            simp at h_fr_assert ⊢
            cases h_map : fr_impl.hyps.toList.mapM (convertHyp db) with
            | none =>
                simp [h_map] at h_fr_assert
            | some hs =>
                simp [h_map] at h_fr_assert ⊢
                cases fr_assert with | mk mand dv =>
                simp at h_fr_assert
                have : hs = mand ∧ fr_impl.dj.toList.map convertDV = dv := h_fr_assert
                simp [this.1]
          -- Now get allM success using the hyps-only frame
          have h_allM_hyps := checkHyp_validates_floats db fr_impl.hyps pr.stack ⟨off, h_off⟩
            assert_hyps_wf assert_floats_wf σ_impl ⟨fr_assert.mand, []⟩ h_chk h_fr_hypsOnly
          -- Bridge.floats only depends on .mand, not .dv
          have h_floats_eq : Bridge.floats ⟨fr_assert.mand, []⟩ = Bridge.floats fr_assert := by
            unfold Bridge.floats
            rfl
          rw [← h_floats_eq]
          exact h_allM_hyps
        -- Apply toSubstTyped_of_allM_true to get TypedSubst witness
        exact toSubstTyped_of_allM_true fr_assert σ_impl h_allM

      -- The conclusion that gets pushed is the INSTANTIATED assertion
      let e_conclusion := Spec.applySubst fr_assert.vars σ_typed.σ e_assert

      -- Build h_match condition for subst_correspondence
      have h_match : ∀ v_var ∈ fr_assert.vars, ∃ f_v, σ_impl[v_var.v]? = some f_v ∧ toExpr f_v = σ_typed.σ v_var := by
        intro v_var h_v_in
        unfold Spec.Frame.vars at h_v_in
        simp [List.mem_filterMap] at h_v_in
        obtain ⟨h_hyp, h_mem_hyp, h_match'⟩ := h_v_in
        cases h_hyp with
        | essential e => simp at h_match'
        | floating c_type v_in_hyp =>
            simp at h_match'
            have h_eq_var : v_in_hyp = v_var := h_match'
            have h_mem_floats : (c_type, v_in_hyp) ∈ Bridge.floats fr_assert :=
              Bridge.floats_complete fr_assert c_type v_in_hyp h_mem_hyp
            unfold toSubstTyped at h_typed
            simp only at h_typed
            split at h_typed
            · rename_i h_allM_success
              have h_point : checkFloat σ_impl c_type v_in_hyp = some true :=
                (List.allM_true_iff_forall _ _ |>.mp) h_allM_success (c_type, v_in_hyp) h_mem_floats
              obtain ⟨f_v, hf, h_size, htc⟩ := checkFloat_success σ_impl c_type v_in_hyp h_point
              refine ⟨f_v, ?_, ?_⟩
              · rw [← h_eq_var]
                exact hf
              · rw [← h_eq_var]
                cases h_typed
                simp only [hf]
            · cases h_typed

      -- Continue with DV checks, substitution, and stack reconstruction
      -- For now, provide stub witnesses
      sorry
