/-
  Metamath/KernelExtras.lean
  Foundation lemmas for Metamath kernel verification.

  All lemmas are fully proven (no axioms!) - Lean 4.20.0-rc2 compatible.
  Proofs provided by Oruži (GPT-5 Pro) - third attempt, addressing mapM.loop
  and field notation issues from earlier attempts.
-/

import Batteries.Data.List.Lemmas
import Batteries.Data.Array.Lemmas

set_option autoImplicit false

namespace KernelExtras

namespace List

/-! ### 1. `mapM` for `Option` — work directly with `mapM.loop` -/

/-- Core lemma: mapM.loop preserves length relationship.

    This is the key that unblocks Lean 4.20.0-rc2's tail-recursive mapM.
    By proving properties about mapM.loop directly (with accumulator),
    we avoid the problematic `simp [List.mapM]` expansion that fails to reduce.

    **Strategy:** Induction on xs, case-split on f x, specialize to Option monad.
-/
private theorem loop_length
  {α β} (f : α → Option β) :
  ∀ (xs : List α) (acc ys : List β),
    List.mapM.loop f xs acc = some ys →
    ys.length = acc.length + xs.length
| [],      acc, ys, h => by
  -- loop base case: mapM.loop [] acc = pure acc.reverse
  simp [List.mapM.loop] at h
  cases h; simp
| x :: xs, acc, ys, h => by
  -- split on f x
  cases hfx : f x with
  | none =>
      -- f x = none → mapM.loop fails
      simp [List.mapM.loop, hfx] at h
  | some y =>
      -- f x = some y → recurse with (y :: acc)
      have : List.mapM.loop f xs (y :: acc) = some ys := by
        simpa [List.mapM.loop, hfx] using h
      have ih := loop_length f xs (y :: acc) ys this
      -- length of (y :: acc) is acc.length + 1
      simpa [Nat.add_comm, Nat.add_left_comm, Nat.add_assoc] using ih

/-- If `List.mapM f xs = some ys` (with `Option`), then `ys.length = xs.length`.

    This is the public API theorem. Implementation: call loop_length with acc = [].
-/
theorem mapM_length_option {α β} (f : α → Option β)
  {xs : List α} {ys : List β} :
  List.mapM f xs = some ys → ys.length = xs.length := by
  intro h
  -- `mapM` calls the loop with `acc = []`
  have := loop_length f xs [] ys (by simpa [List.mapM] using h)
  simpa using this

/-- Normalization for pure lifting: `mapM (some ∘ f) xs = some (map f xs)`. -/
theorem mapM_some_eq_map {α β} (f : α → β) (xs : List α) :
  xs.mapM (fun a => some (f a)) = some (xs.map f) := by
  induction xs with
  | nil => simp
  | cons a xs ih => simp [ih]

/-- Helper lemma: mapM.loop success implies f succeeds on all elements.

    Stronger than the public API - this works on the loop with accumulator.
-/
private theorem loop_some_of_mem {α β} (f : α → Option β) :
  ∀ (xs : List α) (acc ys : List β),
    List.mapM.loop f xs acc = some ys →
    ∀ {x}, x ∈ xs → ∃ b, f x = some b
| [],      acc, ys, h, x, hx => by
    -- x ∈ [] → contradiction
    cases hx
| x' :: xs, acc, ys, h, x, hx => by
    cases hfx : f x' with
    | none =>
        -- f x' = none → loop fails, contradicts h
        simp [List.mapM.loop, hfx] at h
    | some y =>
        -- f x' = some y → recurse
        have h' : List.mapM.loop f xs (y :: acc) = some ys := by
          simpa [List.mapM.loop, hfx] using h
        cases hx with
        | head =>
            -- x = x' → use hfx
            exact ⟨y, hfx⟩
        | tail _ hx' =>
            -- x ∈ xs → use IH
            exact loop_some_of_mem f xs (y :: acc) ys h' hx'

/-- If `List.mapM f xs = some ys` and `x ∈ xs`, then `∃ b, f x = some b`.

    Public API: mapM success guarantees f succeeds on all input elements.
-/
theorem mapM_some_of_mem {α β} (f : α → Option β)
  {xs : List α} {ys : List β} :
  List.mapM f xs = some ys → ∀ {x}, x ∈ xs → ∃ b, f x = some b := by
  intro h x hx
  -- instantiate loop lemma with acc = []
  exact loop_some_of_mem f xs [] ys (by simpa [List.mapM] using h) hx

/-! ### 2. `foldl`/`all` over `Bool` -/

/-- `foldl (and ◦ p)` accumulates to `init && all p xs`.

    Key technique: Avoid field notation (`xs.all p` fails in rc2),
    use `List.all p xs` instead. Generalize over init for flexibility.
-/
theorem foldl_and_eq {α : Type _} (p : α → Bool) :
  ∀ (xs : List α) (init : Bool),
    List.foldl (fun b x => b && p x) init xs
      = (init && List.all xs p)
| [],      init => by simp [List.all]
| x :: xs, init => by
  -- generalize over `init` to keep the IH flexible
  have ih := foldl_and_eq p xs
  -- case split is simpler than leaning on Bool associativity simp in rc2
  cases init <;> cases hpx : p x <;>
    simp [List.foldl, List.all, ih, hpx]

/-- Specialization at `init = true`: foldl with && returns true iff all elements satisfy p.

    This is the form used in Kernel.lean for DV checks.
-/
theorem foldl_and_eq_true {α : Type _} (p : α → Bool) (xs : List α) :
  List.foldl (fun b x => b && p x) true xs = true
    ↔ List.all xs p = true := by
  -- `true && t = t`
  simpa [foldl_and_eq p xs true] using Iff.rfl

/-- Nested `foldl` = nested `all`. This is the DV-scan workhorse.

    For checking disjoint variables: iterate over pairs (x,y) checking p x y.
    The nested fold structure matches the implementation in Verify.lean.
-/
theorem foldl_all₂_true {α β : Type _} (p : α → β → Bool) (xs : List α) (ys : List β) :
  List.foldl
      (fun b x => b && List.foldl (fun b' y => b' && p x y) true ys)
      true xs
    = true
    ↔ xs.all (fun x => ys.all (fun y => p x y)) = true := by
  -- First rewrite the inner fold for each `x`.
  have hInner : ∀ x,
      List.foldl (fun b' y => b' && p x y) true ys
        = ys.all (fun y => p x y) := by
    intro x
    -- specialize `foldl_and_eq` at `init = true`
    simpa [foldl_and_eq (fun y => p x y) ys true]
  -- Then apply `foldl_and_eq_true` once to the outer fold.
  simpa [hInner] using
    (foldl_and_eq_true (fun x => List.foldl (fun b' y => b' && p x y) true ys) xs)

/-- MapM preserves append structure.

    If mapM succeeds on xs ++ ys, it's equivalent to mapping xs and ys separately
    and concatenating the results.

    **Status:** Used in line 3089 (viewStack preservation).
-/
theorem list_mapM_append {α β} (f : α → Option β) (xs ys : List α) :
    (xs ++ ys).mapM f = do
      let xs' ← xs.mapM f
      let ys' ← ys.mapM f
      pure (xs' ++ ys') := by
  induction xs with
  | nil => simp [List.mapM]
  | cons x xs ih =>
      simp [List.mapM]
      cases hfx : f x with
      | none => simp [hfx]
      | some y =>
          simp [hfx]
          rw [ih]
          simp [pure, Bind.bind]

/-- MapM preserves take operation.

    If mapM succeeds on xs, then mapM on xs.take also succeeds and produces ys.take.
-/
theorem list_mapM_take_of_mapM_some {α β} (f : α → Option β) :
  ∀ (xs : List α) (ys : List β) (k : Nat),
    xs.mapM f = some ys →
    (xs.take k).mapM f = some (ys.take k)
| [],      ys, k, h => by cases ys <;> simp at h <;> simp
| x :: xs, ys, 0, h => by simp
| x :: xs, ys, k+1, h =>
  by
    cases h₁ : f x with
    | none   => simp [List.mapM, h₁] at h
    | some y =>
      cases h₂ : xs.mapM f with
      | none      => simp [List.mapM, h₁, h₂] at h
      | some ys'  =>
        have : ys = y :: ys' := by simpa [List.mapM, h₁, h₂] using h
        simp [List.take, h₁, h₂, this]
        exact list_mapM_take_of_mapM_some f xs ys' k h₂

/-- MapM preserves dropLast operation.

    If mapM succeeds on xs, then mapM on xs.dropLast also succeeds and produces
    ys.dropLast.

    **Status:** Used in line 3101 (dropLast preservation).
-/
theorem list_mapM_dropLast_of_mapM_some {α β} (f : α → Option β)
    (xs : List α) (ys : List β) (n : Nat) :
    xs.mapM f = some ys →
    (List.dropLast xs n).mapM f = some (List.dropLast ys n) := by
  intro h
  -- Use the fact that dropLast n = take (length - n)
  have h_len : ys.length = xs.length := mapM_length_option f h
  -- Rewrite dropLast in terms of take
  have hx : xs.dropLast n = xs.take (xs.length - n) := by
    simpa [List.dropLast_eq_take]
  have hy : ys.dropLast n = ys.take (ys.length - n) := by
    simpa [List.dropLast_eq_take]
  -- Use list_mapM_take_of_mapM_some which is now proven above
  have htake := list_mapM_take_of_mapM_some f xs ys (xs.length - n) h
  simpa [hx, hy] using htake

/-- MapM preserves indexing: if mapM succeeds, f succeeds on each element
    and the results correspond by index.

    **Status:** Used in line 3464 (mapM index preservation).
-/
theorem mapM_get_some {α β} (f : α → Option β) (xs : List α) (ys : List β) :
    xs.mapM f = some ys →
    ∀ i : Fin xs.length, ∃ b, f xs[i] = some b ∧ ys[i]'(by rw [mapM_length_option f ‹_›]; exact i.isLt) = b := by
  intro h i
  -- Revert ys to allow induction with i in scope
  revert ys
  -- Induct on xs, generalizing i (key for Fin indices)
  induction xs generalizing i with
  | nil =>
    -- Fin 0 is impossible
    intro ys h
    cases i using Fin.cases
  | cons x xs ih =>
    -- h : (x :: xs).mapM f = some ys
    intro ys h
    -- Case on f x
    cases hf : f x with
    | none =>
      -- mapM would be none, contradiction
      simp [List.mapM, hf] at h
    | some b =>
      -- Now case on tail mapM
      cases hxs : xs.mapM f with
      | none =>
        simp [List.mapM, hf, hxs] at h
      | some ys' =>
        -- Unfold bind: h implies ys = b :: ys'
        simp [List.mapM, hf, hxs] at h
        cases h
        -- Now split on index i (Fin (1 + xs.length))
        cases i using Fin.cases with
        | zero =>
          -- i = 0 (head)
          exists b
          simp [hf]
        | succ j =>
          -- i = j + 1 (tail)
          -- Apply IH to j (note: hxs is the tail success)
          exact ih j ys' hxs

end List

/-! ### 3. Arrays — depend on Batteries/Std lemmas (no unfolding of `get!`) -/

namespace Array

/-- The `i`-th element (as `Fin`) is a member of `toList`.

    Implementation: Use Batteries' existing lemma to avoid re-proving.
    Batteries should provide this (it's in Std); if name differs, use #find.
-/
theorem mem_toList_get {α} (a : Array α) (i : Fin a.size) :
  a[i] ∈ a.toList := by
  -- Direct proof using Array.toList definition and List.get_mem
  have h : i.val < a.toList.length := by simp [Array.toList]
  have : a.toList.get ⟨i.val, h⟩ = a[i] := by simp [Array.toList]
  rw [← this]
  apply List.get_mem

/-- Bridge `get!` (Nat index) to `get` (Fin index) without unfolding it.

    Key: Avoid `simp [getElem!, k.isLt]` which causes infinite recursion.
    Instead, use the fact that getElem! with valid index equals getElem.

    This is true because a[k.val]! uses getD with bounds check, and
    for k : Fin a.size, the bounds check succeeds, returning a[k].
-/
@[simp] theorem getBang_eq_get {α} [Inhabited α]
  (a : Array α) (k : Fin a.size) :
  a[k.val]! = a[k] := by
  cases a using Array.casesOn with
  | mk data =>
    simp [Array.get!, Array.get, Fin.isLt]

end Array

end KernelExtras

-- Re-export for Kernel.lean to use
namespace List
open KernelExtras.List

-- Make these available at top level for backward compatibility
abbrev mapM_length_option : {α β : Type _} → (f : α → Option β) →
  {xs : List α} → {ys : List β} → List.mapM f xs = some ys → ys.length = xs.length :=
  KernelExtras.List.mapM_length_option

abbrev mapM_some_of_mem : {α β : Type _} → (f : α → Option β) →
  {xs : List α} → {ys : List β} → List.mapM f xs = some ys → ∀ {x}, x ∈ xs → ∃ b, f x = some b :=
  KernelExtras.List.mapM_some_of_mem

abbrev foldl_and_eq_true : {α : Type _} → (p : α → Bool) → (xs : List α) →
  List.foldl (fun b x => b && p x) true xs = true ↔ List.all xs p = true :=
  KernelExtras.List.foldl_and_eq_true

abbrev foldl_all₂ : {α β : Type _} → (p : α → β → Bool) → (xs : List α) → (ys : List β) →
  List.foldl (fun b x => b && List.foldl (fun b' y => b' && p x y) true ys) true xs = true ↔
  xs.all (fun x => ys.all (fun y => p x y)) = true :=
  KernelExtras.List.foldl_all₂_true

-- Note: mapM_get_some is available as KernelExtras.List.mapM_get_some
-- Cannot re-export with abbrev due to `by` clause in return type

end List

namespace Array
open KernelExtras.Array

-- Make these available at top level for backward compatibility
abbrev mem_toList_get : {α : Type _} → (a : Array α) → (i : Fin a.size) → a[i] ∈ a.toList :=
  KernelExtras.Array.mem_toList_get

abbrev getBang_eq_get : {α : Type _} → [Inhabited α] → (a : Array α) → (k : Fin a.size) →
  a[k.val]! = a[k] :=
  KernelExtras.Array.getBang_eq_get

end Array
